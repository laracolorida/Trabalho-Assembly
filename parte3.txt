#Gravando os valores do vetor na memória
addi t0, x0, 3
sw t0, 0(gp)
addi t0, x0, 2
sw t0, 4(gp)
addi t0, x0, 1
sw t0, 8(gp)
addi t0, x0, 0
sw t0, 12(gp)
addi t0, x0, 0
sw t0, 16(gp)
addi t0, x0, 1
sw t0, 20(gp)
addi t0, x0, 0
sw t0, 24(gp)
addi t0, x0, 1
sw t0, 28(gp)
addi t0, x0, 2
sw t0, 32(gp)
addi t0, x0, 1
sw t0, 36(gp)
addi t0, x0, 0
sw t0, 40(gp)
addi t0, x0, 1
sw t0, 44(gp)
addi t0, x0, 2
sw t0, 40(gp)
addi t0, x0, 0
sw t0, 52(gp)
addi t0, x0, 1
sw t0, 56(gp)
addi t0, x0, 3
sw t0, 60(gp)
addi t0, x0, 0
sw t0, 64(gp)
addi t0, x0, 1
sw t0, 68(gp)
addi t0, x0, 0
sw t0, 72(gp)
addi t0, x0, 2
sw t0, 76(gp)
addi t0, x0, 2
sw t0, 80(gp)
addi t0, x0, 0
sw t0, 84(gp)
addi t0, x0, 3
sw t0, 88(gp)
addi t0, x0, 2
sw t0, 92(gp)
addi t0, x0, -1
sw t0, 96(gp)


#calculando distancia
add  t6, x0, gp   # Posição inicial dos valores
             
             # X do ponto de referencia
             addi t6, t6, 4
             lw   a0, 0(t6)
             
             # Y do ponto de referencia
             addi t6, t6, 4
             lw   a1, 0(t6)
             
             # Coords do primeiro vizinho
             addi t6, t6, 4
             lw   a2, 0(t6)   # X
             addi t6, t6, 4
             lw   a3, 0(t6)   # Y
                    
             # Enquanto o X daquele ponto nao for -1, calcula a distância e vai pro 
             # próximo ponto. 
             # Uma espécie de loop do while().
             addi t1, x0, -1
             LOOP: beq a2, t1, END_LOOP
			            add a4, x0, a0
                        add a5, x0, a1
                        
                        # DISTANCIA DE MANHATTAN
                        # Calcula as diferenças de x e y
                        sub a4, a4, a2
                        sub a5, a5, a3
                        
                        # Realiza a operação de módulo
                        #srai t3, a4, 31
                        #srai t4, a5, 31
                        
                        #xor a4, a4, t3
                        #xor a5, a5, t4
                        
                        #sub a4, a4, t3
                        #sub a5, a5, t4
                        
                        blt a4, x0, MUL_X
                        jal CHECK_Y
                        MUL_X: mul a4, a4, t1
                        CHECK_Y: blt a5, x0, MUL_Y
                        jal SOMA
                        MUL_Y: mul a5, a5, t1
                        
                        # Soma as coordenadas
                        SOMA: add a4, a4, a5
                        
                        # Salva a diferença ao lado do Y
						add t3, x0, a4
                        slli t3, t3, 8
                        or t3, t3, a3
                        sw t3, 0(t6)
                        
                        # Carrega os próximos pontos
						addi t6, t6, 8
                        
             			lw   a2, 0(t6)   # X
             			addi t6, t6, 4
             			lw   a3, 0(t6)   # Y
                          
                        jal LOOP
                        
                        
END_LOOP: add  t6, x0, gp   # Início do array de pontos
			 addi t5, t6, 20   # Aponta para a classe mais proxima
             add t4, x0, t5    # Aponta para cada classe
             
             addi t3, x6, 255     # Aponta para a MELHOR distancia
			 addi t6, t6, X    # Aponta para cada distancia
             
             lw   a0, 0(t6)
             add s8, x0, a0  # Supondo que a primeira distancia e a melhor.
             
             addi t6, t6, 4 # Vai para a proxima distancia
             lw a0, 0(t6)
             
             # Adiciona mais uma linha de -1 após as distancias
             # Encontra a menor distância.
             DO_WHILE_BUSCA: beq a0, t1, FIM
             		      
                          	 # Atualiza os melhores, se achar um menor
                          	 bge a0, s8, MAIOR  
                             	 add t3, x0, t6
             		  	         add s8, x0, a0
                                 add t5, x0, t4
             		     
                         	# Senao, so vai pro proximo
             		         MAIOR: addi t6, t6, 4  # Vai pra proximo posicao das distancias
                                    addi t4, t4, 12
                             lw   a0, 0(t6)
                             
             		         jal DO_WHILE_BUSCA
             		     
            # Salva 255 na posicao da distancia mais curta para que ela nao se repita
	        FIM: sw 255, 0(t3)
                 lw t0, 0(t5)  # A classe do mais proximo
                 sw t0, XXXXX  # Salva a classe do mais proximo na posicao que vcs quiserem





